<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    Akane - Arisu
    
    </title>
    <link rel="shortcut icon" href="https://gitee.com/saiha/images/raw/main/Arisu/Arisu.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="Arisu" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">主页</a>
                
                <a target="_self" class="navbar-item " href="Apple.html">Apple</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            Akane   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="https://gitee.com/saiha/images/raw/main/Arisu/Arisu.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/07/09</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='%E8%8A%B3%E8%8D%89%E4%B9%8B%E8%AF%97.html'>芳草之诗</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_%E7%AC%94%E8%AE%B0.html'>#笔记</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2><a id="%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用简介</h2>
<p>Akane 是一款视频管理应用，其应用界面以及视频管理逻辑与 iOS 原生应用“视频”接近，并在其基础上增添了一些个性化的功能。Akane 目的是为了用户以更简单的方式管理设备上的视频，以及可以让用户通过 iCloud 同步所有设备上的视频管理信息。</p>
<p>Akane 允许用户：</p>
<ol>
<li>创建视频播放列表。</li>
<li>为播放列表创建缩略图，缩略图在所有登陆 iCloud 的设备上同步。</li>
<li>为视频创建缩略图，缩略图在所有登陆 iCloud 的设备上同步。</li>
<li>通过 mac 上的“访达”应用将 mac 上的视频导入 app 中。</li>
<li>将 iPhone 上其他位置的视频导入到 app 中。</li>
</ol>
<h2><a id="%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发笔记</h2>
<h3><a id="%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图片相关</h3>
<h4><a id="%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图片解码导致的主线程阻塞</h4>
<h5><a id="%E9%97%AE%E9%A2%98%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题：</h5>
<p>Akane 允许用户从相册中选择图片作为视频播放列表的缩略图和影片的缩略图，并通过 iCloud 在各个设备上同步。当 iCloud 中存储了比较多的图片后，这些图片的读取便成了难题。</p>
<p>如果直接将相册中的 png 或者 jpg 格式的图片保存到本地，假设我们展示图片用的是 <code>UIImageView</code>，由于 png 或者 jpg 格式的图片是进行编码压缩后的数据，那么在 <code>imageView.image = image</code> 这一步骤中，系统会将我们读取到的图片数据进行解码，转化成位图数据渲染到屏幕上，这一步是比较耗时的，而且是在主线程完成的，不可避免。</p>
<p>Akane 中展示视频列表用的是 <code>UICollectionView</code>，处理 <code>UICollectionView</code> 的数据源方法为 <code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell</code>。若我们在该方法中进行 <code>cell.imageView = image</code>，那么在数据数量多时，我们对 <code>collectionView</code> 进行滑动时必然会造成卡顿。</p>
<p>另外一个问题是，要进行 <code>cell.imageView = image</code> 这一操作之前，我们必须把所有的图片数据都存入数组中，若图片数量比较多，那么必然造成内存的大量消耗。</p>
<h5><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案一</h5>
<p>在不考虑内存消耗的情况下，我们可以利用 <code>UICollectionView</code> 提供的预加载协议 <code>UICollectionViewDataSourcePrefetching</code>，我们实现该协议的方法：</p>
<pre><code class="language-swift">func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
    let prefetchBlock: (() -&gt; Void) = {
        for indexPath in indexPaths {
            let imageData: Data = self.images[indexPath.row].pngData()!
            self.images[indexPath.row] = decordImage(data: imageData, scale: 0.3)!
        }
    }
    DispatchQueue.global().async {
        prefetchBlock()
    }
}
</code></pre>
<p>在这个方法中，我们将图片的解码操作放在了子线程中，这样就避免了原来的问题。</p>
<p>参考了 AFNetworking 框架中的对图片进行解码的方法，我们可以得到以下图片解码方法：</p>
<pre><code class="language-swift">func decordImage(data: Data, scale: CGFloat) -&gt; UIImage? {
    var imageRef: CGImage? = nil
    let dataProvider: CGDataProvider = CGDataProvider.init(data: data as CFData)!
    imageRef = CGImage.init(pngDataProviderSource: dataProvider, decode: nil, shouldInterpolate: true, intent: .defaultIntent)
    
    let image: UIImage? = UIImage.init(data: data, scale: scale)!
    guard let imageR = imageRef else {
        if image?.images != nil || image == nil {
            return image
        }
        imageRef = image?.cgImage?.copy()
        if imageRef == nil {
            return nil
        }
        return nil
    }
    
    let width: size_t = imageR.width
    let height: size_t = imageR.height
    let bitsPerComponent: size_t = imageR.bitsPerComponent
    if width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8 {
        return image
    }
    
    let bytesPerRow: size_t = 0
    let colorSpace: CGColorSpace = CGColorSpaceCreateDeviceRGB()
    let colorSpaceModel: CGColorSpaceModel = colorSpace.model
    var bitmapInfo: CGBitmapInfo = imageR.bitmapInfo
    if colorSpaceModel == CGColorSpaceModel.rgb {
        let alpha: UInt32 = (bitmapInfo.rawValue &amp; CGBitmapInfo.alphaInfoMask.rawValue)
        if alpha == CGImageAlphaInfo.none.rawValue {
            var newBitmapInfo: UInt32 = (bitmapInfo.rawValue &amp; ~CGBitmapInfo.alphaInfoMask.rawValue)
            newBitmapInfo |= CGImageAlphaInfo.noneSkipFirst.rawValue
            bitmapInfo = CGBitmapInfo.init(rawValue: newBitmapInfo)
        } else if !(alpha == CGImageAlphaInfo.noneSkipFirst.rawValue || alpha == CGImageAlphaInfo.noneSkipLast.rawValue) {
            var newBitmapInfo: UInt32 = bitmapInfo.rawValue &amp; ~CGBitmapInfo.alphaInfoMask.rawValue
            newBitmapInfo |= CGImageAlphaInfo.premultipliedFirst.rawValue
            bitmapInfo = CGBitmapInfo.init(rawValue: newBitmapInfo)
        }
    }
    
    let context: CGContext? = CGContext(data: nil, width: width, height: height, bitsPerComponent: bitsPerComponent, bytesPerRow: bytesPerRow, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)
    if context == nil {
        return image
    }
    context!.draw(imageR, in: CGRect.init(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height)))
    let inflatedImageRef: CGImage = context!.makeImage()!
    return UIImage.init(cgImage: inflatedImageRef)
}
</code></pre>
<h5><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案二</h5>
<p>既然 png 和 jpg 格式的图片渲染到屏幕上时需要解码成位图数据，那么我们不妨在直接读取相册图片时就将图片解码为位图数据后再保存到本地。</p>
<p>针对这个方法，我们可以在数据源方法中有如下代码：</p>
<pre><code class="language-swift">func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
    self.fileCoordinator.coordinate(readingItemAt: iconURL, options: .withoutChanges, error: &amp;self.error) { (url) in
        do {
            let imageData: Data = try Data.init(contentsOf: iconURL)
            cell.imageView.image = UIImage.init(data: imageData)!
        } catch {
            print(error.localizedDescription)
        }
    }
}
</code></pre>
<p>该方法还有一个好处：由于 <code>cell</code> 的复用机制，所以 <code>UICollectionView</code> 的 <code>Cell</code> 具有自动释放其内存的功能。在 <code>cell</code> 自动释放内存时，存储在内存中的位图数据也会随之释放，这样避免了读取许多图片产生的大量内存消耗。</p>
<p>实测在读取本地的 80 部影片时（也就是需要读取 80 张影片缩略图），在快速上下滑动视图的情况下，用解决方案一产生的内存消耗为 441.2 MB，而解决方案二的内存消耗为 180 MB。</p>
<h5><a id="%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两种解决方案比较</h5>
<p>解决方案二确实比解决方案一有更少的内存消耗，而且解决方案一在图片越来越多的情况下，内存消耗也会随之增大，而解决方案二由于具有复用机制，所以不会有这个问题。</p>
<p>但是解决方案二由于在 <code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell</code> 中读取本地位图，之后 <code>cell</code> 被释放时又需要再次从本地读取，这样 app 不停地读取与释放位图数据会产生大量的 CPU 消耗。而解决方案一事先就读取了所有图片，且图片持续保存在内存中，所以不会有如此巨大的 CPU 消耗。</p>
<p>实测在读取本地的 80 部影片时，在快速上下滑动的情况下，解决方案一的 CPU 消耗在 20% 左右，而解决方案二的 CPU 消耗在 95% 以上。</p>
<p>而且由于解决方案一在内存中保存了位图数据，所以在 <code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell</code> 中主线程比较轻松，视图滑动十分流畅。而解决方案二在主线程中需要实时读取本地图片数据，所以在视图快速滑动的情况下不如解决方案一流畅（由于解决方案二不保存图片数据，所以不能在子线程中获取图片）。</p>
<p>另外，由于解决方案一需要事先读取图片，而解决方案二不需要，所以在 <code>push</code> 进视图控制器时，解决方案二比解决方案一更快。</p>
<h5><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E9%99%8D%E9%87%87%E6%A0%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案三：降采样</h5>
<p>解决方案一的优点是在子线程解码图片，于是获得了流畅的视图滑动体验，缺点是耗内存。解决方案二的优点在于较小的内存消耗，缺点在于读取本地图片时牺牲了一部分流畅性。结合两种解决方案的优点我们可以得到一个比较好的解决方案。</p>
<p>首先必须考虑图片的内存消耗问题。假设对于一张 590 KB 大小的图片，其分辨率是 \(2048 px * 1536 px\)，那么它实际使用的内存不是 590 KB，而是 \(2048 * 1536 * 4 = 12 MB\)，这里假设一个像素点占用 4 个字节。</p>
<p>对于该应用来讲，获取一个影片的缩略图我们不需要获得图片的原尺寸，我们可以对图片进行一定程度的裁剪来减小内存的消耗，同时对图片进行解码操作，这样不仅减少了内存的消耗，而且避免了读取本地图片带来的主线程消耗。</p>
<pre><code class="language-swift">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat, location: KHKFileOperation.Location) -&gt; UIImage {
    
    var returnImage: UIImage = UIImage.init()
    let byAccessor: ((URL) -&gt; Void) = { url in
        // 生成 CGImageSourceRef 时，不需要先解码。
        let imageSourceOptions: CFDictionary = [kCGImageSourceShouldCache: false] as CFDictionary
        let imageSource: CGImageSource = CGImageSourceCreateWithURL(url as CFURL, imageSourceOptions)!
        let maxDimensionInPixels: CGFloat = max(pointSize.width, pointSize.height) * scale
        
        // kCGImageSourceShouldCacheImmediately
        // 在创建 Thumbnail 时直接解码，这样就把解码的时机控制在这个 downsample 的函数内。
        let downSampleOptions: CFDictionary = [kCGImageSourceCreateThumbnailFromImageAlways: true,
                                               kCGImageSourceShouldCacheImmediately: true,
                                               kCGImageSourceCreateThumbnailWithTransform: true,
                                               kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary
        let downsampledImage: CGImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downSampleOptions)!
        returnImage = UIImage.init(cgImage: downsampledImage)
    }
    
    if location == .iCloud {
        KHKFileOperation.shared.fileCoordinator.coordinate(readingItemAt: imageURL, options: .withoutChanges, error: &amp;KHKFileOperation.shared.error) { (url) in
            byAccessor(url)
        }
    } else {
        byAccessor(imageURL)
    }
    
    return returnImage
}
</code></pre>
<p>将该步骤放在预加载的子线程当中去执行就可以得到良好的性能。为了避免额外的消耗，我们对每张缩略图增加一个布尔值 <code>prefetch</code>，当该值为 <code>true</code> 时，说明缩略图已经进行过降采样，并已经存储在内存中，当下次需要时我们不必再次对该图进行降采样操作。</p>
<pre><code class="language-swift">var images: Array&lt;(image: UIImage, prefetch: Bool)&gt; = Array&lt;(image: UIImage, prefetch: Bool)&gt;.init()

func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
    DispatchQueue.global().async {
        for indexPath in indexPaths {
            if self.images[indexPath.row].prefetch == false {
                let url: URL = KHKConstant.iCloudMoviesIconImageSavePath!.appendingPathComponent(self.files[indexPath.row].name)
                if FileManager.default.fileExists(atPath: url.path) {
                    let image: UIImage = downsample(imageAt: url, to: KHKConstant.movieThumbSize, scale: 1.0, location: .iCloud)
                    self.images[indexPath.row].image = image
                } else {
                    self.images[indexPath.row].image = getMovieIconFromURL(name: self.files[indexPath.row].name, fileURL: self.files[indexPath.row].fileURL)
                }
            }
        }
        DispatchQueue.main.async {
            var reloadItems: Array&lt;IndexPath&gt; = Array&lt;IndexPath&gt;.init()
            for indexPath in indexPaths {
                if self.images[indexPath.row].prefetch == false {
                    reloadItems.append(indexPath)
                    self.images[indexPath.row].prefetch = true
                }
            }
            if reloadItems.count != 0 {
                self.movieCollectionView.reloadItems(at: reloadItems)
            }
        }
    }
}
</code></pre>
<p>实测读取 80 张影片缩略图时，将图片尺寸从 \(1280 * 720\) 缩减到 \(300 * 168\) 时，内存消耗为 40 MB 左右，且具有良好的流畅性。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
